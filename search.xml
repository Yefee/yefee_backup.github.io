<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[BMA]]></title>
    <url>%2F2018%2F12%2F18%2FBMA%2F</url>
    <content type="text"><![CDATA[How warm the future will be and how certain we areThe ongoing warming is a well-accepted feature of the near future climate change, however how warm it will be and how certain we are remain debatable and unclear, even though significant progress has been made in qualifying the increase in the temperature by averaging an bunch of start-of-the-art climate models (e.g. the CMIP5) or an ensemble of member forecasts from a single model (e.g. CESM-LEN). Here I provide modeling evidence that reveals the increase in temperature and its uncertainty based on Bayesian Inference. Basically, members from an ensemble model prediction is exxtracted randomly, then they are regressed on historical observation data using Bayesian linear regression. Finally these Bayesian models are averaged by stacking the predictive distributions. The results show that the stacking model can largely remove the error in the testing period and predict that the global mean surface air temperature at the end of this century is about 3 oC warmer in RCP8.5 scenario, not as intense as that of the ensemble mean, which warms about 4 oC. The warming mostly occurs at high latitudes but with large certainty which shall be taken into serious consideration by policy makers. Simple inline $ a = b + c $. MethodologyThe BMA method for calibrating forecast ensembles was first introduced by Raftery et al(2008). The BMA predictive PDF of a future weather quantity x is the weighted sum of individual PDFs corresponding to the ensemble members. $$p(x|F_1,…,FM)= \sum{{k=1}^{M}w{k}g{k}(x|F_k)}$$ $$ a = b + c $$where $g_k (x│F_k )$ can be interpreted as the conditional PDF of $x$ conditional on the forecast $F_k$ and weight $w_k$ is the probability of ensemble member k being the best and is based on forecast $Fk$’s performance in the training period. The weights form a probability distribution such that $\sum{{k=1}^{M}w_k} = 1$ and $w_k≥0$. $$\frac{\partial u}{\partial t}= h^2 \left( \frac{\partial^2 u}{\partial x^2} +\frac{\partial^2 u}{\partial y^2} +\frac{\partial^2 u}{\partial z^2}\right)$$]]></content>
      <tags>
        <tag>python, time series, prediction</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XCESM]]></title>
    <url>%2F2017%2F12%2F25%2FXCESM%2F</url>
    <content type="text"><![CDATA[About xcesmXcesm tries to provide an easy-to-use plugin for xarray to better handle CESM output in python. FeaturesXcesm is still in developing, right now it has the following features: quick plot on global map (quickmap) regrid pop output to linear grids (regrid, nearest interpolation) compute global mean (gbmean, gbmeanpop) diagnose AMOC, PRECP, d18O(only support for iCESM), Heat transport etc. truncate ocean as several main basins (ocean_region) More feature will be added in the future. How to installvia git123git clone https://github.com/Yefee/xcesm.gitcd xcesmpython setup.py install How to useregrid1234567891011import xarray as xrimport xcesmds = xr.open_dataset(&apos;/examples/data/salt.nc&apos;)# defalut to 1x1 degreesalt_rgd = ds.SALT.utils.regrid()print(ds.SALT.shape)(384, 320)print(salt_rgd.shape)(181, 361) quick plot1salt_rgd.utils.quickmap() And moreI don’t have time to write documentation recently, but it will be released in this summer!]]></content>
      <tags>
        <tag>python, CESM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GCM Averager]]></title>
    <url>%2F2017%2F12%2F25%2FGCM-Averager%2F</url>
    <content type="text"><![CDATA[About GCMAveragerGCMAverger is a lightweight post process package designed for large amount general circulation model(GCM) outputs using parallel computing.It was originally designed to post process a long run from the community earth system model (CESM), who genreated hundreds of TBs data.NCAR has developed two fancy tools: pyAverager and pyReshaper, which do the samething as GAMAverager, however, they are pooly maintained and not easy to use. GCMAverager is a xarray-based project, therefore python 2.7, 3.4, 3.5, and 3.6 are supported.Right now, GCMAverager primarily can extract variables from time slice history files into time series files; compute annual (decadal) and seasonal mean for model outputs from time slice or time series files. Installationvia github123git clone https://github.com/Yefee/gcmaverager.gitcd gcmaveragerpython setup.py install via pip1pip install gcmaverager Get startedGCMAverager supports several kinds of average method: ANN (annual mean) MAM (March-April-May, annual mean) JJA (June-July-August, annual mean) SON (September-October-November, annual mean) DJF (December-January-February, annual mean) decadal-ANN (decadal annual mean) decadal-MAM (March-April-May, decadal annual mean) decadal-SON (June-July-August, decadal annual mean) decadal-JJA (September-October-November, decadal annual mean) decadal-DJF (December-January-February, decadal annual mean) TS (extract time series file from original GCM outputs) Extract time series file from time slice filesThis feature only suppports Py 3.x. 123456789101112131415161718192021import gcmaverager as gaimport xarray as xrrootDir = &apos;/Volumes/Chengfei_Data_Center/iTrace/test/&apos;tarDir = &apos;/Volumes/Chengfei_Data_Center/iTrace/output/&apos;prefix = &apos;test&apos;suffix = &apos;0001-0999&apos;method = [&apos;TS&apos;]# get file list and create an xarray objectfl = ga.getFilelist(rootDir)ds = xr.open_mfdataset(fl, decode_times=False, atuoclose=True)# derive time dependent variablesvarList = ds.variables.keys()varList = [v for v in varList if &quot;time&quot; in ds[ v].dims and len(ds[v].dims) &gt; 2]# feed it to GAMAveragerfl = [ds[var] for var in varList]ga.averager(fl, tarDir, prefix, suffix, method) The outputs are in tarDir, which has pattern prefix+variable+suffix+’.nc’(e.g. test.TEMP.0001-0999.nc) Compute average from time slice filesThis feature only suppports Py 3.x. 12345678910111213141516171819202122import gcmaverager as gaimport xarray as xrrootDir = &apos;/Volumes/Chengfei_Data_Center/iTrace/test/&apos;tarDir = &apos;/Volumes/Chengfei_Data_Center/iTrace/output/&apos;prefix = &apos;test&apos;suffix = &apos;0001-0999&apos;method = [&apos;ANN&apos;, &apos;decadal-ANN&apos;]# get file list and create an xarray objectfl = ga.getFilelist(rootDir)ds = xr.open_mfdataset(fl, decode_times=False, atuoclose=True)# derive time dependent variablesvarList = ds.variables.keys()varList = [v for v in varList if &quot;time&quot; in ds[ v].dims and len(ds[v].dims) &gt; 2]# feed it to GAMAveragerfl = [ds[var] for var in varList]ga.averager(fl, tarDir, prefix, suffix, method) The outputs are in tarDir, which has pattern prefix+variable+suffix+’ANN.nc’(e.g. test.TEMP.0001-0999.ANN.nc) Compute average from time series files1234567891011121314import gcmaverager as garootDir = &apos;/Volumes/Chengfei_Data_Center/iTrace/test/&apos;tarDir = &apos;/Volumes/Chengfei_Data_Center/iTrace/output/&apos;prefix = &apos;test&apos;suffix = &apos;0001-0999&apos;method = [&apos;ANN&apos;, &apos;decadal-ANN&apos;]# get file list and create an xarray objectfl = ga.getFilelist(rootDir)# feed it to GAMAveragerga.averager(fl, tarDir, prefix, suffix, method)]]></content>
      <tags>
        <tag>python, CESM, Climate Analysis</tag>
      </tags>
  </entry>
</search>
